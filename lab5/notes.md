
    Что происходит при прерывании скрипта text-trap.sh? Объясните, почему.
Вследствие нажатия комбинации Ctrl+C процессу посылается сигнал SIGINT
(он же Signal Interrupt), прописанный  нами trap этот сигнал ловит и 
обрабатывает сообразно заложенным инструкциям (echo Аварийное завершение) 

    Напишите, по какой причине выводы команды ls -l /proc/self и ls -l /proc/$$ отличаются?
/proc/self - символическая ссылка на каталог, отвечающий текущему процессу.
Содержимое этой ссылки непостоянно и меняется относительно обращающегося к ней
Вывод первой команды будет отвечать идентификатору ls. Вывод второй команды
будет соответствовать PID оболочки bash, т.к. $$ - спец. переменная bash.

    Напишите, какие дескрипторы в выводе команды ls -l /proc/self/fd отвечают за stdin, stdout, stderr.
0 отвечает за stdin, 1 - за stdout, а 2 - за stderr.
 
    Что происходит с дескрипторами при перенаправлении потоков stdout и stderr в файлы при выполнении команды ls -l /proc/self/fd > /tmp/ls.out 2> /tmp/ls.err?
Фактически, переназначение файловых дескрипторов потоков вывода и диагностики.
Перенаправление происходит в вышеуказанные файлы.

    Запишите эту же команду, добавив к ней перенаправление потока stdin. Что изменилось?
Команда: ls -l /proc/self/fd < /tmp/ls.in > /tmp/ls/.out 2> /tmp/ls.err
Если все в порядке, вывод команды запишется в /tmp/ls.out, в случае 
возникновения проблем - информация об ошибке запишется в /tmp/ls.err

    Какой эффект наблюдается при выполнении команды exec ps -l?
1. Вывод записывается в стандартный поток вывода. 
2. Завершение процесса оболочки.

    Что означает pos при выводе содержимого файла /proc/$$/fdinfo/3?
Он означает текущую позицию указателя чтения и записи в открытом файле процесса bash.
 
    Существует ли возможность читать содержимое файла test.out даже после его удаления? Почему так происходит?
Удаление файла - удаление указателся на относящийся к нему inode и удаление
содержимого в случае, если не осталось жестких ссылок, указывающих на него.
Если обратимся к файлу через дескриптор (т.е. воспользуемся инодом файла),
то вывод "cat <&4" выведет содержимое файла.


